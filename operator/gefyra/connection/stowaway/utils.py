import re


# This code was generated by Google Gemini
def parse_wg_output(output_string: str) -> dict:
    """
    Parses the string output from the 'wg show' command into a Python dictionary.

    Args:
        output_string: The multi-line string output from 'wg show'.

    Returns:
        A dictionary representing the WireGuard configuration.
    """
    lines = output_string.strip().split("\n")

    wg_data = {"interface": {}, "peers": []}  # type: ignore

    current_context = None
    current_peer = None

    # Regex to parse the transfer line
    transfer_re = re.compile(r"([\d.]+)\s+(.+?)\s+received,\s+([\d.]+)\s+(.+?)\s+sent")
    # Regex for latest handshake
    handshake_re = re.compile(r"(\d+)\s+(second|minute|hour)s?\s+ago")
    # Regex for persistent keepalive
    keepalive_re = re.compile(r"(\d+)\s+seconds")

    for line in lines:
        line = line.strip()

        if not line:
            continue

        if line.startswith("interface:"):
            # Start of the interface section
            iface_name = line.split(":", 1)[1].strip()
            wg_data["interface"]["name"] = iface_name  # type: ignore
            current_context = wg_data["interface"]
            current_peer = None

        elif line.startswith("peer:"):
            # Start of a new peer section
            peer_key = line.split(":", 1)[1].strip()
            current_peer = {"public_key": peer_key}
            wg_data["peers"].append(current_peer)  # type: ignore
            current_context = current_peer

        else:
            # This is a property of the current context (interface or peer)

            if current_context is None:
                continue  # Skip lines before the first interface or peer

            try:
                key, value = re.split(r":\s+", line, maxsplit=1)
                # Clean up the key
                key = key.strip().replace(" ", "_")

                if key == "allowed_ips":
                    # Split comma-separated values into a list
                    current_context[key] = [ip.strip() for ip in value.split(",")]  # type: ignore

                elif key == "transfer":
                    # Parse the transfer line into a sub-dictionary
                    match = transfer_re.match(value)
                    if match:
                        current_context[key] = {  # type: ignore
                            "received": {
                                "value": (
                                    float(match.group(1))
                                    if "." in match.group(1)
                                    else int(match.group(1))
                                ),
                                "unit": match.group(2),
                            },
                            "sent": {
                                "value": (
                                    float(match.group(3))
                                    if "." in match.group(3)
                                    else int(match.group(3))
                                ),
                                "unit": match.group(4),
                            },
                        }
                    else:
                        current_context[key] = value  # type: ignore

                elif key == "latest_handshake":
                    # Parse latest handshake
                    match = handshake_re.match(value)
                    if match:
                        val = int(match.group(1))
                        current_context[key] = {  # type: ignore
                            "value": val,
                            "unit": match.group(2) + ("s" if val != 1 else ""),
                        }
                    else:
                        current_context[key] = value  # type: ignore

                elif key == "persistent_keepalive":
                    # Parse persistent keepalive
                    match = keepalive_re.match(value)
                    if match:
                        current_context[key] = {  # type: ignore
                            "value": int(match.group(1)),
                            "unit": "seconds",
                        }
                    else:
                        current_context[key] = value  # type: ignore

                elif key == "endpoint":
                    # Parse endpoint into host and port
                    try:
                        # Use rsplit to handle IPv6 addresses correctly (splits on last colon)
                        host, port = value.rsplit(":", 1)
                        current_context[key] = {"host": host, "port": int(port)}  # type: ignore
                    except (ValueError, TypeError):
                        current_context[key] = value  # type: ignore

                elif key == "listening_port":
                    # Convert port to integer
                    try:
                        current_context[key] = int(value)  # type: ignore
                    except ValueError:
                        current_context[key] = value  # type: ignore

                else:
                    # Default case: just assign the string value
                    current_context[key] = value  # type: ignore

            except ValueError:
                # Handle lines that might not be key-value pairs (though unlikely)
                pass

    return wg_data
